# Ответ на отзыв

## Используемые обозначения для вопросов
`Fix` - Будет исправлено. \
`Discuss` - Есть какой-то вопрос, надо обсудить. \
`Add` - Функциональность бдует добавлена. \
`Ok` -  Предполагалось такое поведение.

## База данных

В общем:
1. - [x] Таблицы следует называть во множественном числе: например, для сущности `Order` таблицу следует называть `orders`.
> `Fix`
2. - [ ] А почему нет связей, например, между заказом и пользователем?
> `Add`
3. - [ ] А если, вдруг, фабрика захочет производить не только стулья, но и, например, столы?
> `Discuss`
>
> В этом случаи, есть два пути:
> Первый -> Добавить в БД новые таблицы и создать новые сущности.
> Второй -> Изменить базу данных и хранить все материалы в одной таблице,
> при этом нужно будет добавить поле `category`.

### Таблицы материалов (ChairBaseMaterial, ChairUpholsteryMaterial)

1. - [ ] А что будет, если добавится новый вид для материала, например, материал отдельно для ножек или для спинки?
> `Discuss`
>
> В нашей реализации придётся добавлять новую таблицу в БД.
> Но если из прошлого пункта исползовать второй вариант, то проблем не будет, просто добавим новую категорию.
2. - [ ] Как в коде искать какой-то материал, если для него добавляется отдельная обработка? По ID? А если на каком-то контуре ID будет меняться?
> `Discuss`
>
> Не понял вопроса.

### Таблица базовых типов стульев (BasicChair)

1. - [ ] А как в коде искать какой-то определённый тип стульев, если им потребуется дополнительная обработка? По ID? А если на каком-то контуре ID будет меняться?
> `Discuss`
>
> Не понял вопроса.

### Таблица заказов (Order)

1. ~~Почему user_id это string? Опечатка?)~~
> `Ok`
>
> Да, на схеме БД опечатка, `user_id` это `integer`. В коде это поле везде `int`.
2. - [ ] А почему такая сложная структура с массивами из баз, материалов и количества? Почему бы не использовать простой JSON или связи?
> `Fix`
>
> Да, структура достаточно сложная, первое, что пришло на ум) Переделаю используя JSON.

### Таблица пользоватей (User)

1. - [ ] Почему длина пароля 255? А в каком виде он будет храниться?
> `Ok` and `Add`
>
> Пароль будет храниться в хешированном виде.
2. - [ ] А почему только логин и пароль? А как банить пользователей? А если хочется вывести имя пользователю на фронте?
> `Ok` and `Add`
>
> 1.В таблицу `users` добавлю поле `blocked`.
> 2.Так как это тестовый сервис, то БД имеет минимальное кол-во полей для упрощения использования. \
> P.S. Если мы хотим ещё и имя пользователя, то добавим в таблицу `users` поле `username`.

### Таблица ролей (Role)

1. - [ ] А почему есть только роль, но нет "разрешений" (permissions)? Как по коду понимать, можно выполнять пользователю ту или иную операцию?
> `Ok` and `Add`
>
> Для упрощения я предполагал, что роль и будет отвечать за разрешения. \
> У нас будет две роли: `Admin` и `User`. Соответственно человек с ролью `Admin`,
> может выполнять все endpoint'ы (`Admin API + User API`), а человек с роолью `User` может выполнять только endpoint'ы из `User API`. \
> P.S. В коде endpoint'ы помечаны аннотациями `OA\Tag`.

## Код

~~Ну за что REST?~~
> `Ok`
>
> Конечно можно было использовать другие протоколы помимо RST, напримре SOAP, GraphQL или RPC.
> Но мне показалось, что для такого проекта очень хорошо подойдёт именно REST, потому что
> он использует `URI`, данные представляет в `JSON`,
> и в HTTP есть все подходящие методы (`GET`, `POST`, `PUT`, `DELETE`).
> Но и ещё у него хорошая масштабируемость, потому что нет состояний между запросами.
>
> \
> Можем поговорить про минусы других:
> - `SOAP` - достаточно тяжеловесный и считается менее эффективным. А ещё там получаются сложные сообщения из-за XML :).
> - `GraphQL` - он быстрый, но при неправильном использовании будут проблемы с производительностью. А ещё он сложнее, чем `REST`).
> - `RPC` - этот протокол сложно отлаживать, потому что он работает на более низком уровне абстракций. В общем-то он тоже сложнее, чем `REST` :)
>
> \
> В целом, REST проще других, и производительность других нам здесь неважна, поэтому я выбрал тут его.

### Весь проект

1. ~~А почему нужен `twig/extra-bundle` и `twig/twig`?~~
> `Ok`
>
> Чтобы у нас была красивая документация к нашему api.
2. - [x] А почему нужен `symfony/doctrine-messenger`?
> `Fix`
>
> Да, тут он не нужен, удалю.
3. - [x] А почему нужен `symfony/mailer`?
> `Fix`
>
> Он тут также не нужен, поэтому его тоже удалю.
4. ~~А почему перегоняется DTO в DTO? Есть какой-то смысл в использовании `BasicChairArrayItem`, например? А если так, то почему атрибуты не `readonly`?~~
> `Ok` anf `Fix` (переделаю на jsonSerialize)
>
> Смысл `BasicChairArrayItem` описал в основном README.md в разделе [`Вопросы по архитектуре`](https://github.com/Tsygankov-Slava/chair_factory/blob/main/README.md#%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%BF%D0%BE-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B5).
5. - [ ] А где, собственно, логи?
> `Add`
6. - [x] `.idea` надо пихать в `.gitignore`
> `Fix`
>
> Ага, добавлю в `.gitignore`.
7. - [x] Комбинирование `snake_case` и `camelCase` (`App\Entity\Order::$user_id`, `App\Entity\Order::$createdAt`)
> `Fix`
>
> Исправлю.
8. - [ ] Отсутствует сервис для пользователя, нет возможности создать, редактировать и т.д.
> `Add`.
9. ~~Статусы заказа заранее не определены, можем засунуть туда что угодно~~
> `Ok` \
> Для упрощения статусы заказа не определял, потому что с ними не связана никакая функциональность.

### Все контроллеры

1. - [x] Почему возвращаемый тип Response, а не JsonResponse, если везде возвращается JSON?
> `Fix`
2. - [x] Везде есть `json_decode($request->getContent(), true)`, но нигде нет проверки на то, что пришёл действительно JSON
> `Add`
3. - [ ] А где, собственно, валидация? Мы настолько доверяем фронту?
> `Add`
4. - [ ] А где работа с ошибками? Наверное, было бы неплохо залоггировать ошибки, если они возникают?
> `Add`
5. - [ ] А что возвращать фронту в случае ошибки? Тупо 500 и непонятную HTML?
> `Add`
6. - [x] А как будет быстрее работать: через `new JsonResponse($object->jsonSerialize(), 200)` или через `$this->json($object)`?
> `Discuss` and `Fix`
>
> Насколько я знаю, работать будут примерно одинаково. `$this->json()` под капотом использует `new JsonResponse()`. \
> Обычно, если нужна большая гибкость и контроль, лучше использовать JsonResponse. \
> А если нужна краткость и простота, используют $this->json().

### Все выводы списков

1. - [ ] Почему нигде нет сортировок и лимитов?
> `Add`
2. - [ ] Почему везде используется метод `findAll()` у репозиториев сущностей? А если там миллионы записей?
> `Fix`
3. ~~Почему для перегона DTO в DTO не использовать гидратор (отдельный класс, который отвечает за трансформацию одного объекта или массива в другой)?~~
> `Discuss`
>
> Потому что в моём случае ничего не надо перемапивать.

### Методы заказа

#### Общее

1. - [x] А почему `array_push`, а не `$result[] = $item`?
> `Discuss`
>
> Как мне кажеться, тут больше дело вкуса) В производительности разницы почти не будет,
> `array_push` может чуть дольше отработать, потому что будет вызов функции, но это не особо ощутимо.
2. - [ ] А где проверка на то, что длины массивов у материалов, стульев и количества совпадают?
> `Add`
>
> Я подумал, можно возложить эту ответственность на фронт.
3. - [ ] А как пользователю получить один свой заказ, например, текущий?
> `Add`

#### Метод получения списка заказов

1. - [ ] Если уж использовать REST, то должен быть в пути идентификатор заказа, а не пользователя, а идентификатор пользователя GET параметром.
> `Fix`
2. - [ ] А если у пользователя миллион заказов?
> `Fix`
>
> Будут выводиться все) Поставлю лимит на выборку из БД
3. - [ ] А если в заказе 100 элементов, то будет 300 запросов к базе на поиск того или иного элемента заказа? Не многовато ли?
> `Fix`
4. - [ ] А в каком порядке будут выводиться заказы пользователя?
> `Fix`
>
> Сверху старые, снизу новые. Сделаю наоборот.
5. - [x] Условие `if (null === $orders) {` никогда не выполнится, так как `findBy()` всегда возвращает массив, просто он может быть пустым.
> `Fix`

#### Метод создания заказа

1. - [ ] А почему тут не проверяется наличие пользователя? Нам неважно, какой пользователь создаёт заказ? Нам неважно, существует ли пользователь?
> `Add`
2. - [ ] А на вычисление цены при 100 элементах почему 300 запросов к базе?
> `Fix`
3. - [ ] А что, если во время вычисления цены произойдёт удаление того или иного элемента (материала / базового стула)?
> `Discuss` and `Fix`
>
> Мы либо успеем посчитать заказ, либо получим ошибку. \
> Тут наверное стоит использовать транзакции, чтобы мы могли откатиться, если что.
4. ~~А почему статус приходит от фронта? Откуда фронт знает про набор статусов? А если бы у заказа был какой-то путь обработки? Как быть в таком случае?~~
> `Discuss` and `Add`
>
> Да, по хорошему у нас должна быть таблица со статусами, и из неё фронт будет про них знать. \
> Тк статусы нигде не испольуються, я решил эту таблицу не создавать.

### Обновления

1. - [ ] А что увидит пользователь, если у него был заказ год назад, а вот сегодня цены поднялись? Заказ, в котором будет правильная историческая финальная цена и на каждый продукт новые цены?
> `Fix`
>
> Да, финальная цена останеться старой, а стоимости продуктов изменяться.
2. - [ ] А что увидит пользователь, если у него был заказ год назад на стул из кожи с id материала 5, а теперь материал с id 5 - это, например, фанера?
> `Fix`
>
> Пользователь увидит неправильные данные. \
> Тогда в заказе лучше хранить не id, а просто данные сущности.

### Удаления

1. ~~А вообще, удалять из базы данных - это хорошая практика? А если оператор случайно нажал на удаление?~~
> `Discuss`
>
> Иногда из базы данных приходиться удалять например ненужные, устаревшие данные, поэтому это просто вынужденная мера. \
> При этом удалять нужно сохраняя целостность данных.
> Второй возможный вариант это логическое удаление, помечать данные, как удалённые. \
> Но из-за этого потребуеться дополнительная фильтрация и больше памяти :)
2. - [ ] А если попробовать удалить во время расчёта стоимости или формирования ответа по списку заказов?
> `Fix`
>
> Будет либо ошибка, если удаление произойдёт раньше чтения или всё пройдёт успешно, но потом `id` будут невалидны.
3. - [ ] А что увидит пользователь, если у него был заказ год назад на базовый стул с id 4, а сегодня мы удаляем базовый стул с id 4?
> `Fix`
>
> Будет ошибка.
